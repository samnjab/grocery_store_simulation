from __future__ import annotations

from io import StringIO
from typing import TextIO
from store import GroceryStore, Customer, Item, NoAvailableLineError


class Event:
    """An event in our grocery store simulation.

    Events have an ordering based on the event timestamp. For any two events
    e1 and e2, e1 < e2 iff event e1 has a timestamp that is less than event e2.
    This signifies that e1 happens before e2.

    This is an abstract class and should not be instantiated.

    Attributes:
    - timestamp: The time when this event occurs.

    Representation Invariants:
    - timestamp >= 0
    """
    timestamp: int

    def __init__(self, timestamp: int) -> None:
        """Initialize an Event with a given timestamp.

        Preconditions:
            - timestamp >= 0

        >>> Event(7).timestamp
        7
        """
        self.timestamp = timestamp

    def __str__(self) -> str:
        """Return a string representation of the event"""
        return str(self.timestamp)

    # The following three methods allow for comparison of Event instances
    # using the standard comparison operators, such as ==, <, and <=.
    # All methods simply perform the desired comparison on the 'timestamp'
    # attribute of the two events.
    def __eq__(self, other: Event) -> bool:
        """Return whether this Event is equal to <other>.

        Two events are equal iff they have the same timestamp.

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first == second
        False
        >>> second.timestamp = first.timestamp
        >>> first == second
        True
        """
        return self.timestamp == other.timestamp

    def __lt__(self, other: Event) -> bool:
        """Return True iff this Event is less than <other>.

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first < second
        True
        >>> second < first
        False
        """
        return self.timestamp < other.timestamp

    def __le__(self, other: Event) -> bool:
        """Return True iff this Event is less than or equal to <other>.

        >>> first = Event(1)
        >>> second = Event(2)
        >>> first <= first
        True
        >>> first <= second
        True
        >>> second <= first
        False
        """
        return self.timestamp <= other.timestamp

    def do(self, store: GroceryStore) -> list[Event]:
        """Perform this event and return any
        events generated by doing so.
        """
        raise NotImplementedError


class CustomerArrival(Event):
    """A customer arrives at the checkout area ready to join a line and
    check out.

    Attributes:
    - customer: The arriving customer
    """
    timestamp: int
    customer: Customer

    def __init__(self, timestamp: int, c: Customer) -> None:
        """Initialize a CustomerArrival event with the given <timestamp>
        and customer <c>.

        If the customer's arrival time is None, set it now to record
        the fact that this is the time when they first arrived at the
        checkout area. (This is the start of their waiting time.)

        Preconditions:
        - timestamp >= 0
        """
        Event.__init__(self, timestamp)
        self.customer = c

    def __str__(self) -> str:
        """Return a string representation of the event"""
        return f'{Event.__str__(self)} CustomerArrival {str(self.customer)}'

    def do(self, store: GroceryStore, current_time: int) -> list[Event]:
        """ Perform CustomerArrival for the given store, and return
        new events generated by doing so. Events added are as follows:
        - return a CheckoutStarted if customer arrives at an empty checkout.
        - return an empty list if customer is successfully entered a line.
        - return a CustomerArrival for the next interval if there is no
         available checkout line.
        """
        events = []
        try:
            line_number = store.enter_line(self.customer)
            self.customer.arrival_time = current_time
            if store.first_in_line(line_number) == self.customer:
                events.append(CheckoutStarted(current_time, line_number))
        except NoAvailableLineError:
            events.append(CustomerArrival(current_time + 1, self.customer))
        return events


class CheckoutStarted(Event):
    """A customer starts the checkout process in a particular checkout line.

    Attributes:
    - line_number: The number of the checkout line.
    """
    timestamp: int
    line_number: int

    def __init__(self, timestamp: int, line_number: int) -> None:
        """Initialize a CheckoutStarted event with the given <timestamp>
        and <line_number>.

        Preconditions:
        - timestamp >= 0
        - line_number >= 0
        """
        Event.__init__(self, timestamp)
        self.line_number = line_number

    def __str__(self) -> str:
        """Return a string representation of the event"""
        return f'{Event.__str__(self)} CheckoutStarted {self.line_number}'

    def do(self, store: GroceryStore, current_time: int) -> list[Event]:
        """ Perform CheckoutStarted for the given store, and return
       a list of new events generated by doing so as follows:
       - return a CheckoutCompleted for the customer at the front of the line.

       Precondition:
       - The store.checkout_lines[self.line_number] has at least length 1.
       """
        line = self.line_number
        checkout_time = current_time + store.next_checkout_time(line)
        customer = store.first_in_line(line)
        return [CheckoutCompleted(checkout_time, line, customer)]


class CheckoutCompleted(Event):
    """A customer finishes the checkout process.

    Attributes:
    - line_number: The number of the checkout line where a customer
      is finishing.
    - customer: The finishing customer.
    """
    timestamp: int
    line_number: int
    customer: Customer

    def __init__(self, timestamp: int, line_number: int, c: Customer) -> None:
        """Initialize a CheckoutCompleted event.
        """
        Event.__init__(self, timestamp)
        self.line_number = line_number
        self.customer = c

    def __str__(self) -> str:
        """Return a string representation of the event"""
        return f'{Event.__str__(self)} CheckoutCompleted {str(self.customer)}'

    def do(self, store: GroceryStore, current_time: int) -> list[Event]:
        """ Perform CheckoutCompleted for the given store, remove the customer
        from the line, keep a record of the checked out customer, and return
       new events generated by doing so. Events added are as follows:
       - return a CheckoutStarted for the next customer in line.
       - return an empty list if there are no more customers in line.
       Precondition:
       - The store.checkout_lines[self.line_number] has at least length 1.
       """
        events = []
        if store.remove_front_customer(self.line_number) != 0:
            events.append(CheckoutStarted(current_time, self.line_number))
        self.customer.checkout_time = current_time
        return events


class CloseLine(Event):
    """A CheckoutLine gets closed.

    Attributes:
    - line_number: The number of the checkout line.
    """
    timestamp: int
    line_number: int

    def __init__(self, timestamp: int, line_number: int) -> None:
        """Initialize a CloseLine event.
        """
        Event.__init__(self, timestamp)
        self.line_number = line_number

    def __str__(self) -> str:
        """Return a string representation of the event"""
        return f'{Event.__str__(self)} CloseLine {self.line_number}'

    def do(self, store: GroceryStore, current_time: int) -> list[Event]:
        """ Perform a CloseLine event for the given store, remove the customer
        from the line except the first in line, and return new CustomerArrival
        events generated for removed customers. Events added are as follows:
       - return a list of CustomerArrival events for the [1:] customer in line
       in reverse order.
       - return an empty list if there are no more customers in line.

       Precondition:
       - self.line_number < len(store.checkout_lines)
       """
        events = []
        re_customers = store.close_line(self.line_number)
        for i in range(len(re_customers)):
            events.append(CustomerArrival(current_time + i, re_customers.pop()))
        return events


EVENT_SAMPLE = StringIO("""121 Arrive William Bananas 7
22 Arrive Trevor Flowers 22 Bread 3 Cheese 3 Cheese 3
41 Close 0""")


def create_event_list(event_file: TextIO) -> list[Event]:
    """Return a list of Event objects to represent the events in <filename>.

    The events in the list must be in the same order as they are in the file.

    Preconditions:
    - <event_file> is open.
    - <event_file> is in the format specified by the assignment handout.

    >>> samp_events = create_event_list(EVENT_SAMPLE)
    >>> len(samp_events) == 3
    True
    >>> isinstance(samp_events[0], CustomerArrival)
    True
    >>> isinstance(samp_events[2], CloseLine)
    True
    """
    lines = event_file.read().splitlines()
    event_list = []
    for line in lines:
        keywords = line.split()
        timestamp = int(keywords[0])
        event_type = keywords[1]
        if event_type == "Arrive":
            customer = keywords[2]
            items = []
            for i in range(3, len(keywords), 2):
                item = Item(keywords[i], int(keywords[i + 1]))
                items.append(item)
            event = CustomerArrival(timestamp, Customer(customer, items))
            event_list.append(event)
        if event_type == "Close":
            event_list.append(CloseLine(timestamp, int(keywords[2])))
    return event_list


if __name__ == '__main__':
    import doctest

    doctest.testmod()
